"""
Import the CSV database dump generated by SQLMap 
into personal PostgrsSQL database
"""
import os
import sys
from database.connection import Connection
from database.db import DataBase
from utils import Util, Hashing
import argparse
import re
import threading


class ReadContent():
    def __init__(self,server, username, password, delimiter=',', table=None, recreate=False, database=None) -> None:
        self._DEFAULT_DB='postgres'
        self._delimiter = delimiter
        self._connection = Connection(server=server,username=username,password=password)
        self._table= table
        self._recreate = recreate
        self._database = database
    
    def _get_directories(self, directory:str):
        dumpdir = os.path.join(directory,'dump')
        if os.path.exists(dumpdir):
          directories = [name for name in os.listdir(dumpdir) if os.path.isdir(os.path.join(dumpdir, name))]
          return directories,dumpdir


    def start(self, directory:str):
        directories = []
        dumpdir = ""
        if self._database is None:
          directories,dumpdir = self._get_directories(directory)
        else:
            dumpdir = os.path.join(directory,"dump")
            directories.append(self._database)

        if directories is not None:
            db = DataBase(self._DEFAULT_DB, self._connection)
            db.recreate = self._recreate
            
            for dir in directories:
                Util.print(f"Creating database {dir}", color="cyan")
                db.create_database(dir)
                self.create_tables(dir, os.path.join(dumpdir, dir))
        else:
            Util.print_error(f'The {dumpdir} directory does not exists.')
            sys.exit(-1)
    
    def _split_string(self, string):
        pattern = f'[^{self._delimiter}\"]+|\"(?:[^\"]*)\"'
        matches = re.findall(pattern, string)
        return matches

    def insert_data(self, database:str, path:str):
        db = DataBase(database, self._connection)
        db.recreate = self._recreate
        tables=[]
        file = os.path.basename(path)
        index_ext = file.index('.')
        file_name = file[:index_ext].lower()
        print("")
        Util.print(f"Dumping {file}", color="blue")

        csv = open(path, 'r')

        message = ""
        lines = csv.readlines()
        for index, line in enumerate(lines):

            try:
                line = line.strip()
                if line != "":
                    # if "[" in line:
                    #     line = line.replace("\"","").replace("[","").replace("]","").replace("\\","")
                    if index > 0:
                        # Add md5
                        line+=f"{self._delimiter}{Hashing.get_md5(line)}"
                        
                    fields = self._split_string(line.strip())
                    
                    if index == 0:
                        if file_name not in tables:
                            message = f"Creating Table {file_name}"
                            Util.print(message, color="magenta")
                            db.create_table(file_name, fields)
                            tables.append(file_name)
                    else:
                        finished = ""
                        
                        if index>=len(lines)-1:
                            finished = " Ok!"

                        print(f"\rCreating [{file_name}] [{index}/{len(lines)-1}]", end=finished)
                        db.insert_data(file_name, fields)
            except Exception as e:
                txt = f"Error into {file_name} index {index} {e}"
                Util.print_error(txt)
        
    
    def create_tables(self, database:str, directory:str):
        files = []
        threads = []
        for name in os.listdir(directory):
            
            if self._table is not None:
                if name.startswith(self._table+"."):
                    files.append(name)
            else:
                if not name.startswith("."):
                    if os.path.isfile(os.path.join(directory, name)):
                        files.append(name)

        for file in files:
            try:
                file_path = os.path.join(directory, file)
                th = threading.Thread(target=self.insert_data, args=(database,file_path,))
                th.start()
                threads.append(th)
                if len(threads)>=1:
                    for index, t in enumerate(threads):
                        t.join()
                        threads.pop(index)
                    
                #self.insert_data(database, file_path)
            except Exception as e:
                txt = f"Error into {file} => {str(e)}"
                Util.print_error(txt)
    

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-d','--directory', help='Sqlmap output directory', required=True)
    parser.add_argument('-c','--chardelimiter',default=',',help='Delimiter of the dump information')
    parser.add_argument('-s','--host', required=True, help='Postgress server IP/Name')
    parser.add_argument('-u', '--username', required=True, help='Username of the database server')
    parser.add_argument('-p', '--password', required=True, help='Username of the database server')
    parser.add_argument('-t', '--table', required=False, help='Specific table to import')
    parser.add_argument('-D', '--database', required=False, help='Specific database to import')
    parser.add_argument('-f', '--force', required=False, help='Recreate all databases', action="store_true")
    args = parser.parse_args()

    r = ReadContent(delimiter=args.chardelimiter, username=args.username, 
                    server=args.host, password=args.password, table=args.table, 
                    recreate=args.force, database=args.database)
    r.start(args.directory)